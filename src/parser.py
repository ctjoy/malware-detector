import pefile
import argparse
import json
import ntpath
import os

from config.proj import PARSED_DOWLOAD_COM_DATA_DIR
from config.proj import VALID_FEATURES

def create_arg(argv):
  arg_group = argparse.ArgumentParser()

  #group = parser.add_mutually_exclusive_group()
  arg_group.add_argument('-f', '--file')
  arg_group.add_argument('-d', '--dir')
  arg_group.add_argument('-o', '--output')

  return arg_group.parse_args(argv[1:])

def parser(argv):
  args = create_arg(argv)
  if args.file:
    filename = ntpath.basename(args.file)
    feature = get_feature(args.file)
    result = dict()
    result[filename] = feature
    if args.output:
      with open(args.output, 'w') as out:
        json.dump(result, out)
    return result
  elif args.dir:
    print(args)
    result, fail_list = parse_pe_at_dir(args.dir)
    if args.output:
      with open(args.output, 'w') as out:
        json.dump(result, out)
    return result, fail_list

def get_feature(filename):
  pe_header = dict()
  try:
    pe = pefile.PE(filename)
  except Exception as e:
    print('Exception at: ' + ntpath.basename(filename)) 
    print(e)
    return None
  header_feature = dict()

  if not hasattr(pe, 'OPTIONAL_HEADER'):
    print('not get optional header')
    return None
  if not hasattr(pe, 'FILE_HEADER'):
    print('not get file header')
    return None

  tmp = pe.OPTIONAL_HEADER.dump_dict()
  for f in tmp.keys():
    if f in VALID_FEATURES:
      header_feature[f] = tmp[f]['Value']
  tmp = pe.FILE_HEADER.dump_dict()
  for f in tmp.keys():
    if f in VALID_FEATURES:
      header_feature[f] = tmp[f]['Value']

  encoding='ascii'
  dump = pefile.Dump()
  if hasattr(pe, 'DIRECTORY_ENTRY_IMPORT'):
    dump.add_header('Imported symbols')
    for module in pe.DIRECTORY_ENTRY_IMPORT:
      dump.add_lines(module.struct.dump())
      # Print the name of the DLL if there are no imports.
      if not module.imports:
        dump.add('  Name -> {0}'.format(
          pe.get_string_at_rva(module.struct.Name).decode(encoding)))
        dump.add_newline()
      dump.add_newline()
      for symbol in module.imports:
        if symbol.import_by_ordinal is True:
          if symbol.name is not None:
            dump.add('{0}.{1} Ordinal[{2}] (Imported by Ordinal)'.format(
              module.dll.decode('utf-8'),
              symbol.name.decode('utf-8'),
              symbol.ordinal))
          else:
            dump.add('{0} Ordinal[{1}] (Imported by Ordinal)'.format(
              module.dll.decode('utf-8'), symbol.ordinal))
        else:
          dump.add('{0}.{1} Hint[{2:d}]'.format(
            module.dll.decode(encoding),
            symbol.name.decode(encoding),
            symbol.hint))

        if symbol.bound:
          dump.add_line(' Bound: 0x{0:08X}'.format(symbol.bound))
        else:
          dump.add_newline()
      dump.add_newline()
  else:
    print('not get import table')
    return None
  
  impt_dict = dict()
  impt_text = dump.get_text().split('\n')
  for text in impt_text:
    if '.dll' in text:
      impt_item = text.split()
      impt_item = impt_item[0]
      idx_dll = impt_item.find('.dll')
      impt_lib = impt_item[:idx_dll + 4]
      impt_func = impt_item[idx_dll + 5:]
      func_list = impt_dict.get(impt_lib, [])
      func_list.append(impt_func)
      impt_dict[impt_lib] = func_list

  header_feature['ImportTable'] = impt_dict
  return header_feature

def parse_pe_at_dir( pe_dir ):
  fail_parse_list = list()
  if pe_dir[-1] != '/':
    pe_dir += '/'
  result = dict()
  for f in os.listdir(pe_dir):
    feature = get_feature(pe_dir + f)
    if feature is None:
      fail_parse_list.append(f)
      continue
    result[f] = feature

  #with open(json_output_path, 'w') as jop:
  #  json.dump(result, jop)

  return result, fail_parse_list

def dict_to_json( dict_data, file_path ):
  with open(file_path, 'w') as out_file:
    json.dump(dict_data, out_file)